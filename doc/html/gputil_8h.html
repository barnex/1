<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GPU_simulations: gputil.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>gputil.h File Reference</h1><code>#include &quot;<a class="el" href="tensor_8h_source.html">tensor.h</a>&quot;</code><br/>
<code>#include &lt;cufft.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>

<p><a href="gputil_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#ac0a2a829eda78d8c61d65abe004c125e">new_gpu_array</a> (int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtensor.html">tensor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a7c2b7f29fd636e841b2001b07ffb5d18">new_gputensor</a> (int rank, int *size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a9bad0e9d5c5e49d54cc7f681954a990c">new_ram_array</a> (int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#ade18ea7bbea940fcdc15c47f6d05b3e7">gpu_stride_float</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a39fd2af01f3bfd02cf6001c270f652f8">gpu_pad_to_stride</a> (int nFloats)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a9b1f5575ea6503ba9152c1db1fb28cb3">gpu_override_stride</a> (int nFloats)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a9fc3a83fc4e2798b4a70fe5538d3db8f">memcpy_to_gpu</a> (float *source, float *dest, int nElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a587c68bc938e76efa6982de793acf53d">memcpy_from_gpu</a> (float *source, float *dest, int nElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#abb3d67b2b6089e1620679ce812e982fa">memcpy_gpu_to_gpu</a> (float *source, float *dest, int nElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#acc9df64ede1f195cd8188a42a937972f">gpu_array_get</a> (float *dataptr, int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a6f2f5fc9528a4f1e2fc22f1ff8ff7a6e">gpu_array_set</a> (float *dataptr, int index, float value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a8ca9dcaab221f4cf101e18c9dd64612b">tensor_copy_to_gpu</a> (<a class="el" href="structtensor.html">tensor</a> *source, <a class="el" href="structtensor.html">tensor</a> *dest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#ad212066ef724f8314ca9f50148c7ebba">tensor_copy_from_gpu</a> (<a class="el" href="structtensor.html">tensor</a> *source, <a class="el" href="structtensor.html">tensor</a> *dest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#ab771627ffcf287025e3b9d0a0558c541">tensor_copy_gpu_to_gpu</a> (<a class="el" href="structtensor.html">tensor</a> *source, <a class="el" href="structtensor.html">tensor</a> *dest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#ad3d70add006fc3a817675184ebd29fad">gpu_zero</a> (float *data, int nElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a26e74f76194a27b6f685a840a63fb678">gpu_zero_tensor</a> (<a class="el" href="structtensor.html">tensor</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#aadb9a19a5d27210b0ed4dc9a04665826">gpu_safe</a> (int status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a0c42e9df93568af4129f42ef2efbde36">format_gputensor</a> (<a class="el" href="structtensor.html">tensor</a> *t, FILE *out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#aeb3988935e9d689318508ab7dd127e8e">assertHost</a> (float *pointer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#aee41d9d859d5ae5e38c04665701c111a">assertDevice</a> (float *pointer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#aa843a5123b95fbe239b342f375e8a6c2">gpu_checkconf</a> (dim3 gridsize, dim3 blocksize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a7b70f435878eea3e2c5476581369e37f">gpu_checkconf_int</a> (int gridsize, int blocksize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#adc4d57eeb6772ef2ac09f18e384c439c">check3dconf</a> (dim3 gridsize, dim3 blocksize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#adfe62deb142d77cd6b63e3b6a0bf65ba">check1dconf</a> (int gridsize, int blocksize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a5f10ebe67635ce652fa229fa9d8ebc78">make3dconf</a> (int <a class="el" href="gpufft2__test_8cpp.html#a1a345a1e634b1d40f23b3333f3696366">N0</a>, int <a class="el" href="gpufft2__test_8cpp.html#a5a6a26e0827f9640d2eb7201017f19d7">N1</a>, int <a class="el" href="gpufft2__test_8cpp.html#adeea8075a0038c985c63d45161804d60">N2</a>, dim3 *gridSize, dim3 *blockSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a126d013db24c5bdf7552dac353f0e1a8">make1dconf</a> (int N, int *gridSize, int *blockSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a137892fd843da0d82f459f90bb2af209">gpu_getproperties</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#a07dc809bc071234d5b1b2af3dd292860">print_device_properties</a> (FILE *out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gputil_8h.html#ad00a2a5bb51df697f7abd399431962fd">print_device_properties_stdout</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This file provides some common functions for the GPU, like allocating arrays on it...</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd><p class="startdd">use CudaGetDeviceProperties to obtain the maximum number of threads per block, etc... </p>
<p>Strided Arrays </p>
<p>Smart zero-padded FFT's: try strided and transposed </p>
<p class="enddd">choose between in-place and out-of-place FFT's for best performance or best memory efficiency</p>
</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Arne Vansteenkiste </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aee41d9d859d5ae5e38c04665701c111a"></a><!-- doxytag: member="gputil.h::assertDevice" ref="aee41d9d859d5ae5e38c04665701c111a" args="(float *pointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assertDevice </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pointer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>For internal use only.</b></p>
<p>Checks if the data resides on the GPU device by copying one float from device to device. A segmentation fault is thrown when the data resides on the host. </p>

</div>
</div>
<a class="anchor" id="aeb3988935e9d689318508ab7dd127e8e"></a><!-- doxytag: member="gputil.h::assertHost" ref="aeb3988935e9d689318508ab7dd127e8e" args="(float *pointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assertHost </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pointer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>For internal use only.</b></p>
<p>Checks if the data resides on the host by copying one float from host to host. A segmentation fault is thrown when the data resides on the GPU device. </p>

</div>
</div>
<a class="anchor" id="adfe62deb142d77cd6b63e3b6a0bf65ba"></a><!-- doxytag: member="gputil.h::check1dconf" ref="adfe62deb142d77cd6b63e3b6a0bf65ba" args="(int gridsize, int blocksize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check1dconf </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gridsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blocksize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if the CUDA 1D kernel launch configuration is valid. CUDA tends to ignore invalid configurations silently, which is painfull for debugging. Uses device properties </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gridsize</em>&nbsp;</td><td>1D size of the thread grid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocksize</em>&nbsp;</td><td>1D size of the trhead blocks on the grid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc4d57eeb6772ef2ac09f18e384c439c"></a><!-- doxytag: member="gputil.h::check3dconf" ref="adc4d57eeb6772ef2ac09f18e384c439c" args="(dim3 gridsize, dim3 blocksize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check3dconf </td>
          <td>(</td>
          <td class="paramtype">dim3&nbsp;</td>
          <td class="paramname"> <em>gridsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3&nbsp;</td>
          <td class="paramname"> <em>blocksize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if the CUDA 3D kernel launch configuration is valid. CUDA tends to ignore invalid configurations silently, which is painfull for debugging. Uses device properties </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gridsize</em>&nbsp;</td><td>3D size of the thread grid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocksize</em>&nbsp;</td><td>3D size of the trhead blocks on the grid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c42e9df93568af4129f42ef2efbde36"></a><!-- doxytag: member="gputil.h::format_gputensor" ref="a0c42e9df93568af4129f42ef2efbde36" args="(tensor *t, FILE *out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_gputensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtensor.html">tensor</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>For internal use only.</b></p>
<p>Debug function for printing gpu tensors without first having to copy them to host memory manually. </p>

</div>
</div>
<a class="anchor" id="acc9df64ede1f195cd8188a42a937972f"></a><!-- doxytag: member="gputil.h::gpu_array_get" ref="acc9df64ede1f195cd8188a42a937972f" args="(float *dataptr, int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gpu_array_get </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>dataptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>For internal use only.</b></p>
<p>Reads one float from a GPU array, not extremely efficient. </p>

</div>
</div>
<a class="anchor" id="a6f2f5fc9528a4f1e2fc22f1ff8ff7a6e"></a><!-- doxytag: member="gputil.h::gpu_array_set" ref="a6f2f5fc9528a4f1e2fc22f1ff8ff7a6e" args="(float *dataptr, int index, float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu_array_set </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>dataptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>For internal use only.</b></p>
<p>Writes one float to a GPU array, not extremely efficient. </p>

</div>
</div>
<a class="anchor" id="aa843a5123b95fbe239b342f375e8a6c2"></a><!-- doxytag: member="gputil.h::gpu_checkconf" ref="aa843a5123b95fbe239b342f375e8a6c2" args="(dim3 gridsize, dim3 blocksize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu_checkconf </td>
          <td>(</td>
          <td class="paramtype">dim3&nbsp;</td>
          <td class="paramname"> <em>gridsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3&nbsp;</td>
          <td class="paramname"> <em>blocksize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if the CUDA 3D kernel launch configuration is valid. CUDA tends to ignore invalid configurations silently, which is painfull for debugging. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>use <a class="el" href="gputil_8h.html#adc4d57eeb6772ef2ac09f18e384c439c">check3dconf()</a>, which uses the actual device properties </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gridsize</em>&nbsp;</td><td>3D size of the thread grid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocksize</em>&nbsp;</td><td>3D size of the trhead blocks on the grid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b70f435878eea3e2c5476581369e37f"></a><!-- doxytag: member="gputil.h::gpu_checkconf_int" ref="a7b70f435878eea3e2c5476581369e37f" args="(int gridsize, int blocksize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu_checkconf_int </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gridsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blocksize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if the CUDA 1D kernel launch configuration is valid. CUDA tends to ignore invalid configurations silently, which is painfull for debugging. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>use <a class="el" href="gputil_8h.html#adfe62deb142d77cd6b63e3b6a0bf65ba">check1dconf()</a>, which uses the actual device properties </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gridsize</em>&nbsp;</td><td>1D size of the thread grid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocksize</em>&nbsp;</td><td>1D size of the trhead blocks on the grid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a137892fd843da0d82f459f90bb2af209"></a><!-- doxytag: member="gputil.h::gpu_getproperties" ref="a137892fd843da0d82f459f90bb2af209" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* gpu_getproperties </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>For internal use only.</b></p>
<p>Returns a cudaDeviceProp struct that contains the properties of the used GPU. When there are multiple GPUs present, the active one, used by this thread, is considered.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>One global cudaDeviceProp* is stored. The first time this function is called, it gets initialized. All subsequent calls return this cached cudaDeviceProp*. Consequently, the returned pointer must not be freed!</dd></dl>
<p>The struct looks like this: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">char</span> name[256];
    <span class="keywordtype">size_t</span> totalGlobalMem;
    <span class="keywordtype">size_t</span> sharedMemPerBlock;
    <span class="keywordtype">int</span> regsPerBlock;
    <span class="keywordtype">int</span> warpSize;
    <span class="keywordtype">size_t</span> memPitch;
    <span class="keywordtype">int</span> maxThreadsPerBlock;
    <span class="keywordtype">int</span> maxThreadsDim[3];
    <span class="keywordtype">int</span> maxGridSize[3];
    <span class="keywordtype">size_t</span> totalConstMem;
    <span class="keywordtype">int</span> major;
    <span class="keywordtype">int</span> minor;
    <span class="keywordtype">int</span> clockRate;
    <span class="keywordtype">size_t</span> textureAlignment;
    <span class="keywordtype">int</span> deviceOverlap;
    <span class="keywordtype">int</span> multiProcessorCount;
    <span class="keywordtype">int</span> kernelExecTimeoutEnabled;
    <span class="keywordtype">int</span> integrated;
    <span class="keywordtype">int</span> canMapHostMemory;
    <span class="keywordtype">int</span> computeMode;
    <span class="keywordtype">int</span> concurrentKernels;
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>I currently return the cudaDeviceProp* as a void*. In this way, none of the core functions expose cuda stuff directly. This makes it easier to link them with external code (Go, in my case). Arne. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b1f5575ea6503ba9152c1db1fb28cb3"></a><!-- doxytag: member="gputil.h::gpu_override_stride" ref="a9b1f5575ea6503ba9152c1db1fb28cb3" args="(int nFloats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu_override_stride </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nFloats</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>For internal use only.</b></p>
<p>For debugging, it is handy to use a smaller-than-optimal stride; this prevents small test data to be padded to huge proportions. To reset to the intrinsic machine stride, set the value to -1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nFloats</em>&nbsp;</td><td>The stride (in number of floats) to use instead of the real, GPU-dependent stride. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39fd2af01f3bfd02cf6001c270f652f8"></a><!-- doxytag: member="gputil.h::gpu_pad_to_stride" ref="a39fd2af01f3bfd02cf6001c270f652f8" args="(int nFloats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gpu_pad_to_stride </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nFloats</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function takes an array size (in number of floats) and returns an array size -usually larger- that can store the original array and fits the GPU stride. Example (for a stride of 64 floats -- 256 bytes): </p>
<div class="fragment"><pre class="fragment">  1 -&gt; 64
  2 -&gt; 64
 ...
 63 -&gt; 64
 64 -&gt; 64
 65 -&gt; 128
 ...
</pre></div> 
</div>
</div>
<a class="anchor" id="aadb9a19a5d27210b0ed4dc9a04665826"></a><!-- doxytag: member="gputil.h::gpu_safe" ref="aadb9a19a5d27210b0ed4dc9a04665826" args="(int status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu_safe </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>status</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function should be wrapped around cuda functions to check for a non-zero error status. It will print an error message and abort when neccesary. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="gputil_8h.html#aadb9a19a5d27210b0ed4dc9a04665826">gpu_safe</a>( cudaMalloc(...) );
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>CUDA return status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade18ea7bbea940fcdc15c47f6d05b3e7"></a><!-- doxytag: member="gputil.h::gpu_stride_float" ref="ade18ea7bbea940fcdc15c47f6d05b3e7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gpu_stride_float </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the optimal array stride (in number of floats): the second dimension of a 2D array should be a multiple of the stride. This number is usually 64 but could depend on the hardware.</p>
<p>E.g.: it is better to use a 3 x 64 array than a 64 x 3.</p>
<p>This seems to generalize to higher dimensions: at least the last dimension should be a multiple of the stride. E.g.: Standard problem 4 ran about 4x faster when using a (3x) 1 x 32 x 128 geometry instead of (3x) 128 x 32 x 1 !</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>use cudaGetDeviceProperties for this? </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#a39fd2af01f3bfd02cf6001c270f652f8">gpu_pad_to_stride()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3d70add006fc3a817675184ebd29fad"></a><!-- doxytag: member="gputil.h::gpu_zero" ref="ad3d70add006fc3a817675184ebd29fad" args="(float *data, int nElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu_zero </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a range of floats on the GPU to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>data pointer on the GPU </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nElements</em>&nbsp;</td><td>number of floats (not bytes) to be zeroed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26e74f76194a27b6f685a840a63fb678"></a><!-- doxytag: member="gputil.h::gpu_zero_tensor" ref="a26e74f76194a27b6f685a840a63fb678" args="(tensor *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu_zero_tensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtensor.html">tensor</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets all the tensor's elements to zero. The tensor should be allocated on the GPU. </p>

</div>
</div>
<a class="anchor" id="a126d013db24c5bdf7552dac353f0e1a8"></a><!-- doxytag: member="gputil.h::make1dconf" ref="a126d013db24c5bdf7552dac353f0e1a8" args="(int N, int *gridSize, int *blockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make1dconf </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>gridSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>blockSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes a 1D thread configuration suited for a float array of size N The returned configuration will:</p>
<ul>
<li>span the entire array</li>
<li>have the largest valid block size that fits in the array</li>
<li>be valid</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#a5f10ebe67635ce652fa229fa9d8ebc78">make3dconf()</a></dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> gridSize, blockSize;
 <a class="code" href="gputil_8h.html#a126d013db24c5bdf7552dac353f0e1a8">make1dconf</a>(arraySize, &amp;gridSize, &amp;blockSize);
 mykernel&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(arrrrgh);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>size of array to span (number of floats) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gridSize</em>&nbsp;</td><td>grid size is returned here </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>block size is returned here </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f10ebe67635ce652fa229fa9d8ebc78"></a><!-- doxytag: member="gputil.h::make3dconf" ref="a5f10ebe67635ce652fa229fa9d8ebc78" args="(int N0, int N1, int N2, dim3 *gridSize, dim3 *blockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make3dconf </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3 *&nbsp;</td>
          <td class="paramname"> <em>gridSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3 *&nbsp;</td>
          <td class="paramname"> <em>blockSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes a 3D thread configuration suited for a float array of size N0 x N1 x N2. The returned configuration will:</p>
<ul>
<li>span the entire N0 x N1 x N2 array</li>
<li>have the largest valid block size that fits in the N0 x N1 x N2 array</li>
<li>be valid</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>works only up to N2 = 512 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#a126d013db24c5bdf7552dac353f0e1a8">make1dconf()</a></dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment">  dim3 gridSize, blockSize;
  <a class="code" href="gputil_8h.html#a5f10ebe67635ce652fa229fa9d8ebc78">make3dconf</a>(<a class="code" href="gpuconv2__test_8cpp.html#a1a345a1e634b1d40f23b3333f3696366">N0</a>, <a class="code" href="gpuconv2__test_8cpp.html#a5a6a26e0827f9640d2eb7201017f19d7">N1</a>, <a class="code" href="gpuconv2__test_8cpp.html#adeea8075a0038c985c63d45161804d60">N2</a>, &amp;gridSize, &amp;blockSize);
  mykernel&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(arrrrgh);
  
  __global__ <span class="keywordtype">void</span> mykernel(aaarghs){
    
    <span class="keywordtype">int</span> i = ((blockIdx.x * blockDim.x) + threadIdx.x)
    <span class="keywordtype">int</span> j = ((blockIdx.y * blockDim.y) + threadIdx.y)
    <span class="keywordtype">int</span> k = ((blockIdx.z * blockDim.z) + threadIdx.z)
    
    ...
  }
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N0</em>&nbsp;</td><td>size of 3D array to span </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N1</em>&nbsp;</td><td>size of 3D array to span </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N2</em>&nbsp;</td><td>size of 3D array to span </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gridSize</em>&nbsp;</td><td>grid size is returned here </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>block size is returned here </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a587c68bc938e76efa6982de793acf53d"></a><!-- doxytag: member="gputil.h::memcpy_from_gpu" ref="a587c68bc938e76efa6982de793acf53d" args="(float *source, float *dest, int nElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void memcpy_from_gpu </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies floats from GPU to the main RAM. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#a9fc3a83fc4e2798b4a70fe5538d3db8f">memcpy_to_gpu()</a>, <a class="el" href="gputil_8h.html#abb3d67b2b6089e1620679ce812e982fa">memcpy_gpu_to_gpu()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source data pointer on the GPU </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination data pointer in the RAM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nElements</em>&nbsp;</td><td>number of floats (not bytes) to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb3d67b2b6089e1620679ce812e982fa"></a><!-- doxytag: member="gputil.h::memcpy_gpu_to_gpu" ref="abb3d67b2b6089e1620679ce812e982fa" args="(float *source, float *dest, int nElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void memcpy_gpu_to_gpu </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies floats from GPU to GPU. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#a9fc3a83fc4e2798b4a70fe5538d3db8f">memcpy_to_gpu()</a>, <a class="el" href="gputil_8h.html#a587c68bc938e76efa6982de793acf53d">memcpy_from_gpu()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source data pointer on the GPU </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination data pointer on the GPU </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nElements</em>&nbsp;</td><td>number of floats (not bytes) to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fc3a83fc4e2798b4a70fe5538d3db8f"></a><!-- doxytag: member="gputil.h::memcpy_to_gpu" ref="a9fc3a83fc4e2798b4a70fe5538d3db8f" args="(float *source, float *dest, int nElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void memcpy_to_gpu </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies floats from the main RAM to the GPU. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#a587c68bc938e76efa6982de793acf53d">memcpy_from_gpu()</a>, <a class="el" href="gputil_8h.html#abb3d67b2b6089e1620679ce812e982fa">memcpy_gpu_to_gpu()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source data pointer in the RAM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination data pointer on the GPU </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nElements</em>&nbsp;</td><td>number of floats (not bytes) to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0a2a829eda78d8c61d65abe004c125e"></a><!-- doxytag: member="gputil.h::new_gpu_array" ref="ac0a2a829eda78d8c61d65abe004c125e" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* new_gpu_array </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates an array of floats on the GPU and asserts the size is a multiple of 512. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#a9bad0e9d5c5e49d54cc7f681954a990c">new_ram_array()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c2b7f29fd636e841b2001b07ffb5d18"></a><!-- doxytag: member="gputil.h::new_gputensor" ref="a7c2b7f29fd636e841b2001b07ffb5d18" args="(int rank, int *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtensor.html">tensor</a>* new_gputensor </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new tensor whose data is allocated on the GPU. (rank and size are stored in the host RAM) </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>delete_gputensor() </dd></dl>

</div>
</div>
<a class="anchor" id="a9bad0e9d5c5e49d54cc7f681954a990c"></a><!-- doxytag: member="gputil.h::new_ram_array" ref="a9bad0e9d5c5e49d54cc7f681954a990c" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* new_ram_array </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates an array of floats in the main RAM. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#ac0a2a829eda78d8c61d65abe004c125e">new_gpu_array()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07dc809bc071234d5b1b2af3dd292860"></a><!-- doxytag: member="gputil.h::print_device_properties" ref="a07dc809bc071234d5b1b2af3dd292860" args="(FILE *out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_device_properties </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints the properties of the used GPU </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>stream to print to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad00a2a5bb51df697f7abd399431962fd"></a><!-- doxytag: member="gputil.h::print_device_properties_stdout" ref="ad00a2a5bb51df697f7abd399431962fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_device_properties_stdout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad212066ef724f8314ca9f50148c7ebba"></a><!-- doxytag: member="gputil.h::tensor_copy_from_gpu" ref="ad212066ef724f8314ca9f50148c7ebba" args="(tensor *source, tensor *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensor_copy_from_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtensor.html">tensor</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtensor.html">tensor</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies the source tensor (on the GPU) to the the destination tensor (in RAM). They should have equal sizes. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#a8ca9dcaab221f4cf101e18c9dd64612b">tensor_copy_to_gpu()</a>, <a class="el" href="gputil_8h.html#ab771627ffcf287025e3b9d0a0558c541">tensor_copy_gpu_to_gpu()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab771627ffcf287025e3b9d0a0558c541"></a><!-- doxytag: member="gputil.h::tensor_copy_gpu_to_gpu" ref="ab771627ffcf287025e3b9d0a0558c541" args="(tensor *source, tensor *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensor_copy_gpu_to_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtensor.html">tensor</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtensor.html">tensor</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies the source tensor to the the destination tensor (both on the GPU). They should have equal sizes. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#a8ca9dcaab221f4cf101e18c9dd64612b">tensor_copy_to_gpu()</a>, <a class="el" href="gputil_8h.html#ad212066ef724f8314ca9f50148c7ebba">tensor_copy_from_gpu()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ca9dcaab221f4cf101e18c9dd64612b"></a><!-- doxytag: member="gputil.h::tensor_copy_to_gpu" ref="a8ca9dcaab221f4cf101e18c9dd64612b" args="(tensor *source, tensor *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensor_copy_to_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtensor.html">tensor</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtensor.html">tensor</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies the source tensor (in RAM) to the the destination tensor (on the GPU). They should have equal sizes. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gputil_8h.html#ad212066ef724f8314ca9f50148c7ebba">tensor_copy_from_gpu()</a>, <a class="el" href="gputil_8h.html#ab771627ffcf287025e3b9d0a0558c541">tensor_copy_gpu_to_gpu()</a> </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Jul 6 16:19:19 2010 for GPU_simulations by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
