.TH "gpufft2.h" 3 "6 Jul 2010" "GPU_simulations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
gpufft2.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'tensor.h'\fP
.br
\fC#include 'gputil.h'\fP
.br
\fC#include <cufft.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBgpuFFT3dPlan\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBgpuFFT3dPlan\fP * \fBnew_gpuFFT3dPlan_padded\fP (int *size, int *paddedsize)"
.br
.ti -1c
.RI "\fBgpuFFT3dPlan\fP * \fBnew_gpuFFT3dPlan\fP (int *size)"
.br
.ti -1c
.RI "void \fBgpuFFT3dPlan_forward\fP (\fBgpuFFT3dPlan\fP *plan, \fBtensor\fP *input, \fBtensor\fP *output)"
.br
.ti -1c
.RI "void \fBgpuFFT3dPlan_inverse\fP (\fBgpuFFT3dPlan\fP *plan, \fBtensor\fP *input, \fBtensor\fP *output)"
.br
.ti -1c
.RI "void \fBgpuFFT3dPlan_forward_unsafe\fP (\fBgpuFFT3dPlan\fP *plan, float *input, float *output)"
.br
.ti -1c
.RI "void \fBgpuFFT3dPlan_inverse_unsafe\fP (\fBgpuFFT3dPlan\fP *plan, float *input, float *output)"
.br
.ti -1c
.RI "int \fBgpuFFT3dPlan_normalization\fP (\fBgpuFFT3dPlan\fP *plan)"
.br
.ti -1c
.RI "void \fBgpu_tensor_transposeYZ_complex\fP (\fBtensor\fP *source, \fBtensor\fP *dest)"
.br
.ti -1c
.RI "void \fBgpu_tensor_transposeXZ_complex\fP (\fBtensor\fP *source, \fBtensor\fP *dest)"
.br
.ti -1c
.RI "void \fBgpu_transposeXZ_complex\fP (float *source, float *dest, int \fBN0\fP, int \fBN1\fP, int \fBN2\fP)"
.br
.ti -1c
.RI "__global__ void \fB_gpu_transposeXZ_complex\fP (float *source, float *dest, int \fBN0\fP, int \fBN1\fP, int \fBN2\fP)"
.br
.ti -1c
.RI "void \fBgpu_transposeYZ_complex\fP (float *source, float *dest, int \fBN0\fP, int \fBN1\fP, int \fBN2\fP)"
.br
.ti -1c
.RI "__global__ void \fB_gpu_transposeYZ_complex\fP (float *source, float *dest, int \fBN0\fP, int \fBN1\fP, int \fBN2\fP)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Like gpufft but works on tensors instead of float*'s
.PP
Initialization, execution and deleting of FFTs used during the computation of the micromagnetic kernel. The following is taken into account:
.IP "\(bu" 2
real-to-complex FFTs
.IP "\(bu" 2
No FFTs on the zeros in the padded magnetization buffers
.IP "\(bu" 2
The CUDA memory access is aligned
.PP
.PP
\fBTodo\fP
.RS 4
In place transpose routines: swap if sourceIndex > destIndex 
.PP
Option for out-of place transforms 
.PP
normalization_factor();
.RE
.PP
\fBAuthor:\fP
.RS 4
Arne Vansteenkiste 
.PP
Ben Van de Wiele 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "__global__ void _gpu_transposeXZ_complex (float * source, float * dest, int N0, int N1, int N2)"
.SS "__global__ void _gpu_transposeYZ_complex (float * source, float * dest, int N0, int N1, int N2)"
.SS "void gpu_tensor_transposeXZ_complex (\fBtensor\fP * source, \fBtensor\fP * dest)".PP
\fBFor internal use only.\fP
.RS 4
\fBSee also:\fP
.RS 4
\fBgpu_transposeYZ_complex()\fP 
.RE
.PP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP source data, size N0 x N1 x (2*N2) 
.br
\fIdest\fP destination data, size N2 x N1 x (2*N0) 
.RE
.PP

.SS "void gpu_tensor_transposeYZ_complex (\fBtensor\fP * source, \fBtensor\fP * dest)".PP
\fBFor internal use only.\fP
.RS 4
Swaps the Y and Z components of a 3D array of complex numbers. N0 x N1 x N2/2 complex numbers are stored as N0 x N1 x N2 interleaved real numbers. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP source data, size N0 x N1 x (2*N2) 
.br
\fIdest\fP destination data, size N0 x N2 x (2*N1) 
.RE
.PP

.SS "void gpu_transposeXZ_complex (float * source, float * dest, int N0, int N1, int N2)"
.SS "void gpu_transposeYZ_complex (float * source, float * dest, int N0, int N1, int N2)"
.SS "void gpuFFT3dPlan_forward (\fBgpuFFT3dPlan\fP * plan, \fBtensor\fP * input, \fBtensor\fP * output)"Forward (real-to-complex) transform. Tensor sizes are checked. 
.PP
\fBSee also:\fP
.RS 4
\fBgpuFFT3dPlan_forward_unsafe()\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIplan\fP the plan to be executed 
.br
\fIinput\fP input data, it's size should match the strided 'half complex' format (=plan->paddedStorageSize) 
.br
\fIoutput\fP output data, may be equal to input for in-place transforms. 
.RE
.PP

.SS "void gpuFFT3dPlan_forward_unsafe (\fBgpuFFT3dPlan\fP * plan, float * input, float * output)".PP
\fBFor internal use only.\fP
.RS 4
Forward (real-to-complex) transform. Sizes are not checked. 
.PP
\fBSee also:\fP
.RS 4
\fBgpuFFT3dPlan_forward()\fP 
.RE
.PP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIplan\fP the plan to be executed 
.br
\fIinput\fP input data, it's size should match the strided 'half complex' format (=plan->paddedStorageSize) 
.br
\fIoutput\fP output data, may be equal to input for in-place transforms. 
.RE
.PP

.SS "void gpuFFT3dPlan_inverse (\fBgpuFFT3dPlan\fP * plan, \fBtensor\fP * input, \fBtensor\fP * output)"Backward (complex-to-real) transform. Tensor sizes are checked. 
.PP
\fBSee also:\fP
.RS 4
\fBgpuFFT3dPlan_inverse_unsafe()\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIplan\fP the plan to be executed 
.br
\fIinput\fP input data, may be equal to output for in-place transforms. 
.br
\fIoutput\fP output data, it's size should match the strided 'half complex' format (=plan->paddedStorageSize) 
.RE
.PP

.SS "void gpuFFT3dPlan_inverse_unsafe (\fBgpuFFT3dPlan\fP * plan, float * input, float * output)".PP
\fBFor internal use only.\fP
.RS 4
Backward (complex-to-real) transform. Sizes are not checked. 
.PP
\fBSee also:\fP
.RS 4
\fBgpuFFT3dPlan_inverse()\fP 
.RE
.PP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIplan\fP the plan to be executed 
.br
\fIinput\fP input data, may be equal to output for in-place transforms. 
.br
\fIoutput\fP output data, it's size should match the strided 'half complex' format (=plan->paddedStorageSize) 
.RE
.PP

.SS "int gpuFFT3dPlan_normalization (\fBgpuFFT3dPlan\fP * plan)"FFT normalization factor. After forward + inverse transforming, the data will be multiplied by this factor. It is equal to kernelSize[X] * kernelSize[Y] * kernelSize[Z]; 
.SS "\fBgpuFFT3dPlan\fP* new_gpuFFT3dPlan (int * size)"Creates a general real-to-complex 3D FFT plan. 
.PP
\fBNote:\fP
.RS 4
This is equivalent to 
.PP
.nf
 new_gpuFFT3dPlan_padded(size, size);

.fi
.PP
 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP size of real input data (3D) 
.RE
.PP

.SS "\fBgpuFFT3dPlan\fP* new_gpuFFT3dPlan_padded (int * size, int * paddedsize)"Creates a new real-to-complex 3D FFT plan with efficient handling of padding zeros. If paddedsize is larger than size, then the additional space is filled with zeros, but they are efficiently handled during the transform. 
.PP
\fBTodo\fP
.RS 4
: better give paddedstoragesize? is less confusing. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP size of real input data (3D) 
.br
\fIpaddedsize\fP size of the padded data (3D). Should be at least the size of the input data. If the kernel is larger, the input data is assumed to be padded with zero's which are efficiently handled by the FFT 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for GPU_simulations from the source code.
