.TH "param.h" 3 "6 Jul 2010" "GPU_simulations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
param.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'assert.h'\fP
.br
\fC#include 'tensor.h'\fP
.br
\fC#include <stdio.h>\fP
.br
\fC#include <stdlib.h>\fP
.br
\fC#include <math.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBparam\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBPI\fP   3.14159265"
.br
.ti -1c
.RI "#define \fBNONE\fP   0"
.br
.RI "\fIPossible value for any type (anisotropy, solver, exchange, ...). \fP"
.ti -1c
.RI "#define \fBANIS_UNIAXIAL\fP   1"
.br
.RI "\fIPossible value for anisType. Means uniaxial anisotropy. \fP"
.ti -1c
.RI "#define \fBANIS_CUBIC\fP   2"
.br
.RI "\fIPossible value for anisType. Means cubic anisotropy. \fP"
.ti -1c
.RI "#define \fBANIS_EDGE\fP   3"
.br
.RI "\fIPossible value for anisType. Means shape anisotropy. \fP"
.ti -1c
.RI "#define \fBSOLVER_EULER\fP   1"
.br
.RI "\fIPossible value for solverType. Simple Euler method. \fP"
.ti -1c
.RI "#define \fBSOLVER_HEUN\fP   2"
.br
.RI "\fIPossible value for solverType. 2nd order Heun method. \fP"
.ti -1c
.RI "#define \fBSOLVER_RK4\fP   4"
.br
.RI "\fIPossible value for solverType. 4th order Runge-Kutta. \fP"
.ti -1c
.RI "#define \fBSOLVER_DP45\fP   45"
.br
.RI "\fIPossible value for solverType. 5th order Dormand-Prince with adaptive step size. \fP"
.ti -1c
.RI "#define \fBSOLVER_ANAL_FW\fP   128"
.br
.RI "\fIPossible value for solverType. Ben Van de Wiele's forward semi-analytical solver. \fP"
.ti -1c
.RI "#define \fBSOLVER_ANAL_PC\fP   256"
.br
.RI "\fIPossible value for solverType. Ben Van de Wiele's predictor/corrector semi-analytical solver. \fP"
.ti -1c
.RI "#define \fBEXCH_6NGBR\fP   6"
.br
.RI "\fIPossible value for exchType. 6-neighbour exchange. \fP"
.ti -1c
.RI "#define \fBKERNEL_DIPOLE\fP   1"
.br
.ti -1c
.RI "#define \fBKERNEL_MICROMAG2D\fP   2"
.br
.RI "\fIPossible value for kernelType. Quantities only dependent on Y and Z coordinate, invariance in X direction. Includes exchange. \fP"
.ti -1c
.RI "#define \fBKERNEL_MICROMAG3D\fP   3"
.br
.RI "\fIPossible value for kernelType. Classical 3D micromagnetic kernel. Can also be used for 2D simulations (1 cell in X). Includes exchange. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBcheck_param\fP (\fBparam\fP *p)"
.br
.ti -1c
.RI "\fBparam\fP * \fBnew_param\fP ()"
.br
.RI "\fINew param with default values. \fP"
.ti -1c
.RI "void \fBdelete_param\fP (\fBparam\fP *p)"
.br
.RI "\fIFrees everything. \fP"
.ti -1c
.RI "double \fBunitlength\fP (\fBparam\fP *p)"
.br
.RI "\fIThe internal unit of length, expressed in meters. \fP"
.ti -1c
.RI "double \fBunittime\fP (\fBparam\fP *p)"
.br
.RI "\fIThe internal unit of time, expressed in seconds. \fP"
.ti -1c
.RI "double \fBunitfield\fP (\fBparam\fP *p)"
.br
.RI "\fIThe internal unit of field, expressed in tesla. \fP"
.ti -1c
.RI "double \fBunitenergy\fP (\fBparam\fP *p)"
.br
.RI "\fIThe internal unit of energy, expressed in J. \fP"
.ti -1c
.RI "void \fBparam_print\fP (FILE *out, \fBparam\fP *p)"
.br
.RI "\fIPrints the parameters. \fP"
.in -1c
.SH "Detailed Description"
.PP 
The params struct stores simulation parameters like
.IP "\(bu" 2
material constants
.IP "\(bu" 2
simulation size
.IP "\(bu" 2
demag type
.IP "\(bu" 2
time stepping parameters By convention, these parameters are only changed by the user, \fInot\fP by the simulation itself (e.g.: a solver itself must not change the maxDt parameter, etc.).
.PP
.PP
Should there be a need for a central place to store all variables that \fIare\fP changed during the simulation (like m, h, time, ...), then a second struct can be made for this.
.PP
\fBWarning:\fP
.RS 4
Unless otherwise noted, all values represent internal units. Conversion from SI units is typically done right after the input file is read, and conversion back to SI is done right before output is written. In between, everything is doen in internal units, even if not noted explicitly.
.RE
.PP
The internal program units are well adapted to the intrinsic scale of the problem. This avoids having to deal with extremely large or small quantities, which may lead to numerical errors. Our program units are chosen so that the values of the following four quantities become one:
.PP
.IP "\(bu" 2
msat (saturation magnetization of the used material, A/m)
.IP "\(bu" 2
eaxch (exchange constant of the used material, J/m)
.IP "\(bu" 2
gamma0 (gyromagnetic ratio, 2.211E5 m/As)
.IP "\(bu" 2
mu0 (permeability of vacuum, 4pi*1E-7 N/A^2)
.PP
.PP
This leads to the following set of program units:
.PP
.IP "\(bu" 2
Unit of field: msat * mu0
.IP "\(bu" 2
Unit of length: sqrt(2aexch/(mu0 * msat^2)), the exchange length
.IP "\(bu" 2
Unit of time:1/(gamma0 * msat)
.IP "\(bu" 2
Unit of energy: aexch * unitlength
.PP
.PP
The param struct provides an easy way to keep track of the internal simulation units. A new unit system is created with \fBnew_param()\fP, after which aexch and msat can be set. Then, \fBunitlength()\fP, \fBunittime()\fP, \fBunitfield()\fP and \fBunitenergy()\fP can be called to get the respective internal units expressed in SI units.
.PP
\fBNote:\fP
.RS 4
gamma0 and mu0 are set to their default values, but can be changed if desired.
.RE
.PP
\fBAuthor:\fP
.RS 4
Arne Vansteenkiste, Ben Van de Wiele 
.RE
.PP

.SH "Define Documentation"
.PP 
.SS "#define ANIS_CUBIC   2"
.PP
Possible value for anisType. Means cubic anisotropy. 
.SS "#define ANIS_EDGE   3"
.PP
Possible value for anisType. Means shape anisotropy. 
.SS "#define ANIS_UNIAXIAL   1"
.PP
Possible value for anisType. Means uniaxial anisotropy. 
.SS "#define EXCH_6NGBR   6"
.PP
Possible value for exchType. 6-neighbour exchange. 
.SS "#define KERNEL_DIPOLE   1"
.SS "#define KERNEL_MICROMAG2D   2"
.PP
Possible value for kernelType. Quantities only dependent on Y and Z coordinate, invariance in X direction. Includes exchange. 
.SS "#define KERNEL_MICROMAG3D   3"
.PP
Possible value for kernelType. Classical 3D micromagnetic kernel. Can also be used for 2D simulations (1 cell in X). Includes exchange. 
.SS "#define NONE   0"
.PP
Possible value for any type (anisotropy, solver, exchange, ...). 
.SS "#define PI   3.14159265"
.SS "#define SOLVER_ANAL_FW   128"
.PP
Possible value for solverType. Ben Van de Wiele's forward semi-analytical solver. 
.SS "#define SOLVER_ANAL_PC   256"
.PP
Possible value for solverType. Ben Van de Wiele's predictor/corrector semi-analytical solver. 
.SS "#define SOLVER_DP45   45"
.PP
Possible value for solverType. 5th order Dormand-Prince with adaptive step size. 
.SS "#define SOLVER_EULER   1"
.PP
Possible value for solverType. Simple Euler method. 
.SS "#define SOLVER_HEUN   2"
.PP
Possible value for solverType. 2nd order Heun method. 
.SS "#define SOLVER_RK4   4"
.PP
Possible value for solverType. 4th order Runge-Kutta. 
.SH "Function Documentation"
.PP 
.SS "void check_param (\fBparam\fP * p)"checks if the parameter list has acceptable values. 
.SS "void delete_param (\fBparam\fP * p)"
.PP
Frees everything. \fBTodo\fP
.RS 4
implement 
.RE
.PP

.SS "\fBparam\fP* new_param ()"
.PP
New param with default values. 
.SS "void param_print (FILE * out, \fBparam\fP * p)"
.PP
Prints the parameters. 
.SS "double unitenergy (\fBparam\fP * p)"
.PP
The internal unit of energy, expressed in J. 
.SS "double unitfield (\fBparam\fP * p)"
.PP
The internal unit of field, expressed in tesla. 
.SS "double unitlength (\fBparam\fP * p)"
.PP
The internal unit of length, expressed in meters. 
.SS "double unittime (\fBparam\fP * p)"
.PP
The internal unit of time, expressed in seconds. 
.SH "Author"
.PP 
Generated automatically by Doxygen for GPU_simulations from the source code.
