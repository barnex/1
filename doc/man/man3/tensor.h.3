.TH "tensor.h" 3 "6 Jul 2010" "GPU_simulations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
tensor.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib.h>\fP
.br
\fC#include <stdio.h>\fP
.br
\fC#include <stdarg.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBtensor\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBX\fP   0"
.br
.ti -1c
.RI "#define \fBY\fP   1"
.br
.ti -1c
.RI "#define \fBZ\fP   2"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBtensor\fP * \fBnew_tensor\fP (int rank,...)"
.br
.ti -1c
.RI "\fBtensor\fP * \fBnew_tensorN\fP (int rank, int *size)"
.br
.ti -1c
.RI "\fBtensor\fP * \fBas_tensor\fP (float *list, int rank,...)"
.br
.ti -1c
.RI "\fBtensor\fP * \fBas_tensorN\fP (float *list, int rank, int *size)"
.br
.ti -1c
.RI "void \fBdelete_tensor\fP (\fBtensor\fP *t)"
.br
.ti -1c
.RI "void \fBdelete_tensor_component\fP (\fBtensor\fP *t)"
.br
.ti -1c
.RI "void \fBtensor_zero\fP (\fBtensor\fP *t)"
.br
.ti -1c
.RI "void \fBtensor_copy\fP (\fBtensor\fP *source, \fBtensor\fP *dest)"
.br
.ti -1c
.RI "int \fBtensor_equalsize\fP (\fBtensor\fP *a, \fBtensor\fP *b)"
.br
.ti -1c
.RI "int * \fBtensor_size3D\fP (int *size4D)"
.br
.ti -1c
.RI "int * \fBtensor_size4D\fP (int *size3D)"
.br
.ti -1c
.RI "\fBtensor\fP * \fBtensor_component\fP (\fBtensor\fP *t, int component)"
.br
.ti -1c
.RI "int \fBtensor_length\fP (\fBtensor\fP *t)"
.br
.ti -1c
.RI "float * \fBtensor_elem\fP (\fBtensor\fP *t, int *index)"
.br
.ti -1c
.RI "float * \fBtensor_get\fP (\fBtensor\fP *t, int rank,...)"
.br
.ti -1c
.RI "int \fBtensor_index\fP (\fBtensor\fP *t, int *indexarray)"
.br
.ti -1c
.RI "float ** \fBtensor_array2D\fP (\fBtensor\fP *t)"
.br
.ti -1c
.RI "float ** \fBslice_array2D\fP (float *list, int size0, int size1)"
.br
.ti -1c
.RI "float *** \fBtensor_array3D\fP (\fBtensor\fP *t)"
.br
.ti -1c
.RI "float *** \fBslice_array3D\fP (float *list, int size0, int size1, int size2)"
.br
.ti -1c
.RI "float **** \fBtensor_array4D\fP (\fBtensor\fP *t)"
.br
.ti -1c
.RI "float **** \fBslice_array4D\fP (float *list, int size0, int size1, int size2, int size3)"
.br
.ti -1c
.RI "float ***** \fBtensor_array5D\fP (\fBtensor\fP *t)"
.br
.ti -1c
.RI "float ***** \fBslice_array5D\fP (float *list, int size0, int size1, int size2, int size3, int size4)"
.br
.ti -1c
.RI "void \fBwrite_tensor\fP (\fBtensor\fP *t, FILE *out)"
.br
.ti -1c
.RI "void \fBwrite_tensor_fname\fP (\fBtensor\fP *t, char *filename)"
.br
.ti -1c
.RI "void \fBwrite_tensor_pieces\fP (int rank, int *size, float *data, FILE *out)"
.br
.ti -1c
.RI "\fBtensor\fP * \fBread_tensor\fP (FILE *in)"
.br
.ti -1c
.RI "\fBtensor\fP * \fBread_tensor_fname\fP (char *filename)"
.br
.ti -1c
.RI "void \fBread_tensor_pieces\fP (int *rank, int **size, float **list, FILE *in)"
.br
.ti -1c
.RI "void \fBwrite_tensor_ascii\fP (\fBtensor\fP *t, FILE *out)"
.br
.ti -1c
.RI "void \fBformat_tensor\fP (\fBtensor\fP *t, FILE *out)"
.br
.ti -1c
.RI "void \fBprint_tensor\fP (\fBtensor\fP *t)"
.br
.ti -1c
.RI "void \fBwrite_int\fP (int i, FILE *out)"
.br
.ti -1c
.RI "void \fBwrite_float\fP (float f, FILE *out)"
.br
.ti -1c
.RI "void * \fBsafe_malloc\fP (int size)"
.br
.ti -1c
.RI "void * \fBsafe_calloc\fP (int length, int elemsize)"
.br
.in -1c
.SH "Detailed Description"
.PP 
tensor provides a common interface for N-dimensional arrays of floats. The tensor type knows its rank and sizes in each dimension, so these do not have to be passed to function calls. Tensors can also be input/output in a common format, for sharing them between different programs or storing them in files.
.PP
For an example how to use the tensor type, see \fBtensor_test.cpp\fP
.PP
\fBTodo\fP
.RS 4
->array (void*) 
.PP
->gpu? 
.PP
remove variadic functions, they sometimes give problems.
.RE
.PP
\fBAuthor:\fP
.RS 4
Arne Vansteenkiste 
.RE
.PP

.SH "Define Documentation"
.PP 
.SS "#define X   0"
.SS "#define Y   1"
.SS "#define Z   2"
.SH "Function Documentation"
.PP 
.SS "\fBtensor\fP* as_tensor (float * list, int rank,  ...)"Makes a tensor form existing data. 
.PP
\fBSee also:\fP
.RS 4
\fBas_tensorN()\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP array of data to wrapped in the tensor 
.br
\fIrank\fP rank of the new tensor 
.RE
.PP

.SS "\fBtensor\fP* as_tensorN (float * list, int rank, int * size)"Makes a tensor form existing data, without varargs. 
.PP
\fBSee also:\fP
.RS 4
\fBas_tensor()\fP
.RE
.PP
\fBNote:\fP
.RS 4
this is the 'master constructor'. All other constructors should call this one 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP array of data to wrapped in the tensor 
.br
\fIrank\fP rank of the new tensor 
.br
\fIsize\fP sizes in each dimension, as many as rank 
.RE
.PP

.SS "void delete_tensor (\fBtensor\fP * t)"Frees the tensor, including its data list. Make sure no pointers to that list exist anymore, otherwise, \fBdelete_tensor_component()\fP can be used to free everything but the data list. 
.PP
\fBSee also:\fP
.RS 4
\fBdelete_tensor_component()\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIt\fP the tensor to be deleted 
.RE
.PP

.SS "void delete_tensor_component (\fBtensor\fP * t)"Frees the tensor struct and all its members, except 'list' (which points to the data array). Tensors created by \fBtensor_component()\fP should not be freed with \fBdelete_tensor()\fP but with \fBdelete_tensor_component()\fP, as the parent tensor may still be using the data list. The same goes for tensors created with \fBas_tensor()\fP if a pointer to the data list still exists, or for any tensor whose ->list has been stored somewhere. 
.SS "void format_tensor (\fBtensor\fP * t, FILE * out)"Prints the tensor in ascii text, but with nicer formatting: outputs a matrix in rows/columns, etc. 
.SS "\fBtensor\fP* new_tensor (int rank,  ...)"Creates a new tensor with given rank and size (as integer varargs). Allocates the neccesary space for the elements. Initializes with zeros. 
.PP
\fBSee also:\fP
.RS 4
\fBnew_tensorN()\fP 
.RE
.PP
\fBDeprecated\fP
.RS 4
No compliation error arises when used with an int* as second argument. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIrank\fP rank of the new tensor 
.RE
.PP

.SS "\fBtensor\fP* new_tensorN (int rank, int * size)"The same as \fBnew_tensor()\fP, but with the size given as an array. This is only neccesary when the rank is not known at compile time, otherwise just use \fBnew_tensor()\fP. 
.PP
\fBSee also:\fP
.RS 4
\fBnew_tensor()\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIrank\fP rank of the new tensor 
.br
\fIsize\fP sizes in each dimension, the number of elements should be equal to rank. 
.RE
.PP

.SS "void print_tensor (\fBtensor\fP * t)"Prints the tensor to standard output. 
.SS "\fBtensor\fP* read_tensor (FILE * in)"Reads the tensor from binary format. 
.SS "\fBtensor\fP* read_tensor_fname (char * filename)"Reads from a file referenced by name instead of FILE* 
.SS "void read_tensor_pieces (int * rank, int ** size, float ** list, FILE * in)"Can be used as an alternative for \fBread_tensor()\fP if you don't want to use the tensor struct. 
.SS "void* safe_calloc (int length, int elemsize)"A malloc that may print an error message instead of just causing a segfault when unable to allocate. 
.SS "void* safe_malloc (int size)"A malloc that may print an error message instead of just causing a segfault when unable to allocate. 
.SS "float** slice_array2D (float * list, int size0, int size1)".PP
\fBFor internal use only.\fP
.RS 4
wraps the storage of a 1D array in a 2D array of given size. 
.RE
.PP

.SS "float*** slice_array3D (float * list, int size0, int size1, int size2)"\fBSee also:\fP
.RS 4
\fBslice_array2D()\fP 
.RE
.PP

.SS "float**** slice_array4D (float * list, int size0, int size1, int size2, int size3)"\fBSee also:\fP
.RS 4
\fBslice_array2D()\fP 
.RE
.PP

.SS "float***** slice_array5D (float * list, int size0, int size1, int size2, int size3, int size4)"\fBSee also:\fP
.RS 4
\fBslice_array2D()\fP 
.RE
.PP

.SS "float** tensor_array2D (\fBtensor\fP * t)"An easy way to acces tensor's elements is to view it as an N-dimensional array. Given a rank 2 tensor, this function returns a 2-dimensional array containing the tensor's data. 
.SS "float*** tensor_array3D (\fBtensor\fP * t)"\fBSee also:\fP
.RS 4
\fBtensor_array2D()\fP 
.RE
.PP

.SS "float**** tensor_array4D (\fBtensor\fP * t)"\fBSee also:\fP
.RS 4
\fBtensor_array2D()\fP 
.RE
.PP

.SS "float***** tensor_array5D (\fBtensor\fP * t)"\fBSee also:\fP
.RS 4
\fBtensor_array2D()\fP 
.RE
.PP

.SS "\fBtensor\fP* tensor_component (\fBtensor\fP * t, int component)"Makes a slice of a tensor, sharing the data with the original. Example 
.PP
.nf
  tensor* t = new_tensor(2, 3, 40); // 3 x 40 matrix
  tensor* t_row0 = tensor_component(t, 0); // points to row 0 of t

.fi
.PP
 
.SS "void tensor_copy (\fBtensor\fP * source, \fBtensor\fP * dest)"Copies source into dest. They should have equal sizes. 
.SS "float* tensor_elem (\fBtensor\fP * t, int * index)"Returns the address of element i,j,k,... inside the tensor. This can be used to set or get elements form the tensor. The index is checked against the tensor size and the code aborts when the index is out of bounds. Of course, the 'manual' way: t->list[i*size + j ...] can still be used as well. 
.PP
\fBSee also:\fP
.RS 4
\fBtensor_get()\fP 
.RE
.PP

.SS "int tensor_equalsize (\fBtensor\fP * a, \fBtensor\fP * b)"Checks whether both tensors have equal rank and size. 
.PP
\fBReturns:\fP
.RS 4
1 for equal sizes, 0 otherwise. 
.RE
.PP

.SS "float* tensor_get (\fBtensor\fP * t, int rank,  ...)"Same as \fBtensor_elem()\fP, but with varargs for ease of use. The index is checked against the tensor size and the code aborts when the index is out of bounds. Example: 
.PP
.nf
  tensor* t = new_tensor(2, 100, 100);
  *tensor_get(2, i, j) = 3.14;    
  float elemIJ = *tensor_get(2, i, j);

.fi
.PP
 
.PP
\fBSee also:\fP
.RS 4
\fBtensor_elem()\fP 
.RE
.PP

.SS "int tensor_index (\fBtensor\fP * t, int * indexarray)"Given an N-dimensional index (i, j, k, ...), this function calculates the 1-dimensional index in the corresponding array that stores the tensor data. Thus, tensor_elem(i,j,k) is equivalent to list[tensor_index(i,j,k)]. The index is checked against the tensor size and the code aborts when the index is out of bounds. 
.SS "int tensor_length (\fBtensor\fP * t)"Returns the total number of elements in the tensor: size[0]*size[1]*...*size[rank-1]. This is also the length of the contiguous array that stores the tensor data. 
.PP
\fBDeprecated\fP
.RS 4
use tensor->len instead 
.RE
.PP

.SS "int* tensor_size3D (int * size4D)".PP
\fBFor internal use only.\fP
.RS 4
Takes an array of 4 integers {3, N0, N1, N2} and returns the array {N0, N1, N2} 
.RE
.PP

.SS "int* tensor_size4D (int * size3D)".PP
\fBFor internal use only.\fP
.RS 4
Takes an array of 3 integers {N0, N1, N2} and returns the array {3, N0, N1, N2} 
.RE
.PP

.SS "void tensor_zero (\fBtensor\fP * t)"Sets all the tensor's elements to zero. 
.SS "void write_float (float f, FILE * out)"
.SS "void write_int (int i, FILE * out)"
.SS "void write_tensor (\fBtensor\fP * t, FILE * out)"Writes the tensor in binary format: All data is written as 32-bit words, either integers or floats. The first word is an integer that stores the rank N. The next N words store the sizes in each of the N dimensions (also integers). The remaining words are floats representing the data in row-major (C) order.
.PP
\fBNote:\fP
.RS 4
currently the data is stored in the endianess of the machine. It might be nicer to store everything in big endian, though. 
.RE
.PP

.SS "void write_tensor_ascii (\fBtensor\fP * t, FILE * out)"Prints the tensor as ascii text. The format is just the same as \fBwrite_tensor()\fP, but with ascii output instead of binary. This can also be used to print to the screen: write_tensor_ascii(tensor, stdout);
.PP
Todo: does anyone want a read_tensor_ascii() ? 
.SS "void write_tensor_fname (\fBtensor\fP * t, char * filename)"Writes to a file referenced by name instead of FILE* 
.SS "void write_tensor_pieces (int rank, int * size, float * data, FILE * out)"Can be used as an alternative for \fBwrite_tensor()\fP if you don't want to use the tensor struct. 
.SH "Author"
.PP 
Generated automatically by Doxygen for GPU_simulations from the source code.
