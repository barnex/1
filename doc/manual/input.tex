\section{Running \mumax}


\subsection{Python input files}

\mumax input files can be written in Python, among others. Let us start with a simple example input file: \file{standardproblem4.py}

\begin{verbatim}
from mumax import *

# material
msat(800e3)
aexch(1.3e-11)
alpha(0.02)

# geometry 
gridsize(128, 32, 1)
partsize(500e-9, 125e-9, 3e-9)

# initial magnetization
uniform	(1, 1, 0)
relax(1e-5)

# run
autosave('table', 'ascii', 10E-12)
run(1e-9)
\end{verbatim}


\subsection{raw ".in" input files}


\begin{verbatim}
# material
msat       	800e3 
aexch      	1.3e-11
alpha      	0.02

# geometry 
gridsize	1     	32      128    
partsize	500e-9	125e-9 	3e-9

# initial magnetization
uniform		1 1 0

# run
autosave	table	ascii	10E-12
run          	1E-9
\end{verbatim}

\newcommand{\defcommand}[2][\space]{\textbf{#2}\index{#2}\label{#2} \textit{#1}}
\newcommand{\command}[1]{\hyperref[#1]{\textbf{#1}}\index{#1}\label{#1}}

\paragraph{Comments} All text after a hashmark (\#) is considered a \idx{comment} and is ignored by the simulation. In the above example, the statements \cmd{\# material}, \cmd{\# geometry}, \ldots are thus comments. They are only included for clarity and could be omitted.

\paragraph{Commands} All the other text in the input file is treated as a series of \idx{commands} that are executed in the order they are specified. In general, the order of the commands matters but should be easy to deduce.  E.g., you can not call \command{run} to start the time evolution when you have not first specified the material parameters, simulation size, etc\ldots. On the other hand, after having {run} the simulation for some time, you \emph{can} change the material parameters and call commands like \command{run} again. Either way, the program will tell you if it can not run a certain command yet because some parameters should be set first. A list of commands is found below.

\subsubsection*{Material parameters}
\begin{tabular}{ll}
\defcommand[value]{msat}  & Sets the saturation magnetization to the value specified in A/m. \\
\defcommand[value]{aexch} & Sets the exchange constant to the value specified in J/m. \\
\defcommand[value]{alpha} & Sets the damping coefficient.
\end{tabular}

\subsubsection*{Part size}
To define the magnet size, you must specify \emph{exactly two} of the three commands below.\\

\begin{tabular}{ll}
\defcommand[x y z]{partsize}  & Sets the size of the magnet, specified in m. \\
\defcommand[x y z]{cellsize}  & Sets the size of the finite difference cells, in m. \\
\defcommand[$N_x$ $N_y$ $N_z$]{gridsize} & Sets the number of finite difference cells.
\end{tabular}\\
\bigskip

\begin{itemize}
 \item After having set two of these values, the remaining one is calculated automatically. E.g. the part size and cell size automatically fix the number of cells.
 \item For performance reasons, the number of cells in each direction should preferentially be a power of two.
 \item For a 2D simulation, one can simply use $N_x \times N_y \times 1$ cells. In that case, optimized algorithms for a 2D geometry are used. Note that only the last dimension ($Z$) can be $1$ cell large, e.g., $1 \times N_y \times N_z$ is not a valid grid size.
\end{itemize}


\subsubsection*{Initial magnetization state}
\begin{tabular}{ll}
\defcommand[$m_x$ $m_y$ $m_z$]{uniform}  & Initializes the magnetization to a uniform state.\\
\defcommand[amplitude]{addnoise} & Adds random noise with the specified amplitude to a previously\\& defined magnetization state.
\end{tabular}




\subsubsection{Applied magnetic field}
\begin{tabular}{ll}
\defcommand[$B_x$ $B_y$ $B_z$]{staticfield}  & Applies a static magnetic field, specified in tesla.\\
\end{tabular}

\subsubsection*{Scheduled output}
\begin{tabular}{ll}
\defcommand[what format interval]{autosave}  & $what$ = m (magnetization) or table.\\
& $format$ = ascii, binary or png.\\
& $interval$ = save output every $interval$ seconds.
\end{tabular}


\subsection{Output}


Upon running an input file, an \idx{output directory} with a corresponding name but ending with ``\file{.out}'' will be created to store the simulation output. It also contains a file \idxfile{output.log} that keeps a log of all the output that appeared on the screen.  


\subsection{\mumax Arguments}

\mumax is generally started by typing:

\shell{\prog \textit{arguments} \textit{inputfile}}

in a terminal. \cmd{\textit{arguments}} represents the (optional) \idx{command line arguments}, starting with a dash (``-'') or double-dash. These should always be specified \emph{before} the input file(s). They are meant for fine-tuning the program's behavior and may often be omitted. Here are the most important cases:

\begin{tabular}{ll}
\idxcmd{-help} & Print a complete list of command-line arguments.\\
\idxcmd{-cpu} & Run on the CPU instead of the GPU. \\
\idxcmd{-gpu=N}&  Run on GPU number ``N'' when multiple GPUs are present.\\& Default value is ``0'', the first GPU. \\
\idxcmd{-silent}&  Do not print output to the screen (only to output.log) \\
\idxcmd{-updatedisp=N}&  Update the ``live'' progress output every N milliseconds \\
\idxcmd{-daemon}&  Run in deamon mode, see \ref{daemon} \\
\idxcmd{-watch=N}&  When running in deamon mode, check for new input files every ``N'' seconds. See \ref{daemon}. \\
\end{tabular}

