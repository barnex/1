\section{Input files}


\mumax input files can be written in Python, among others. Let us start with a simple example input file: \file{standardproblem4.py}

\begin{verbatim}
from mumax import *

# material
msat(800e3)
aexch(1.3e-11)
alpha(0.02)

# geometry 
gridsize(128, 32, 1)
partsize(500e-9, 125e-9, 3e-9)

# initial magnetization
uniform	(1, 1, 0)
relax(1e-5)

# run
autosave('table', 'ascii', 10E-12)
run(1e-9)
\end{verbatim}


\subsection{Material parameters}

msat(m): Sets the saturation magnetization in A/m
aexch(a): Sets the exchange constant in J/m

# Sets the damping parameter alpha(a):
	send1("alpha", a)


# Sets the anisotropy constant K1
def k1(k):
	send1("k1", k)

# Defines the uniaxial anisotropy axis.
def anisuniaxial(ux, uy, uz):
	send3("anisuniaxial", ux, uy, uz)


# Geometry

# Sets the number of FD cells
def gridsize(nx, ny, nz):
	send3("gridsize", nx, ny, nz)

# Sets the size of the magnet, in meters
def partsize(x, y, z):
	send3("partsize", x, y, z)

# Sets the cell size, in meters
def cellsize(x, y, z):
	send3("cellsize", x, y, z)

# Sets the maximum cell size, in meters
def maxcellsize(x, y, z):
	send3("maxcellsize", x, y, z)

# Make the geometry an ellipsoid with specified semi-axes.
# Use inf to make it a cyliner along that direction.
def ellipsoid(rx, ry, rz):
	send3("ellipsoid", rx, ry, rz)

# Initial magnetization

# Loads the magnetization state from a .omf file
def loadm(filename):
	send1("loadm", filename)

# Sets the magnetization to the uniform state (mx, my, mz)
def uniform(mx, my, mz):
	send3("uniform", mx, my, mz)

# Adds random noise to the magnetization
def addnoise(amplitude):
	send1("addnoise", amplitude)

# Initializes the magnetization to a random state
def setrandom():
	send0("setrandom")

# Sets the magnetization to a vortex state
def vortex(circulation, polarization):
	send2("vortex", circulation, polarization)

# Sets the magnetization in cell with index i,j,k to (mx, my, mz)
def setmcell(i, j, k, mx, my, mz):
	send("setmcell", [i, j, k, mx, my, mz])

# Sets the magnetization in cell position x, y, z (in meters) to (mx, my, mz)
def setm(x, y, z, mx, my, mz):
	send("setmcell", [x, y, z, mx, my, mz])

# Sets the magnetization to a ransendm state
def setransendm():
	send0("setransendm")

# Sets the ransendm number seed
def seed(s):
	send1("seed", s)

# Output

# Single-time save with automatic file name
def save(what, format):
	send2("save", what, format)

# Periodic auto-save
def autosave(what, format, periodicity):
	send3("autosave", what, format, periodicity)


# Solver

# Sets the solver type. E.g.: rk32, rk4, semianal...
def solvertype(solver):
	send1("solvertype", solver)

# Sets the maximum tolerable estimated error per solver step
def maxerror(error):
	send1("maxerror", error)

# Sets the maximum time step 
def maxdt(dt):
	send1("maxdt", dt)

# Sets the minimum time step 
def mindt(dt):
	send1("mindt", dt)

# Sets the maximum magnetization step 
def maxdm(dm):
	send1("maxdm", dm)

# Sets the minimum magnetization step 
def mindm(dm):
	send1("mindm", dm)

# Excitation

# Apply a static field
def staticfield(bx, by, bz):
	send3("staticfield", bx, by, bz)

# Apply an RF field
def rffield(bx, by, bz, freq):
	send("rffield", [bx, by, bz, freq])

# Apply a sawtooth field
def sawtoothfield(bx, by, bz, freq):
	send("sawtoothfield", [bx, by, bz, freq])

# Apply a rotating RF burst
def rotatingburst(b, freq, phase, risetime, duration):
	send("rotatingburst", [b, freq, phase, risetime, duration])

# Run

# Relaxes the magnetization up to the specified maximum residual torque
def relax():
	send0("relax")

# Runs for the time specified in seconds
def run(time):
	send1("run", time)


# Misc

# Adds a description tag
def desc(key, value):
	send2("desc", key, value)	

# Save benchmark info to file
def savebenchmark(file):
	send1("savebenchmark", file)


# Recieve feedback from mumax

# Retrieves an average magnetization component (0=x, 1=y, 2=z).
def getm(component):
	send1("getm", component)
	return recv()


# Debug and fine-tuning

# Override whether the exchange interaction is included in the magnetostatic convolution.
def exchinconv(b):
	send1("exchinconv", b)

# Set the exchange type (number of neighbors)
def exchtype(t):
	send1("exchtype", t)

# Override the subcommand for calculating the magnetostatic kernel
def kerneltype(cmd):
	send1("kerneltype", cmd)


\subsection{raw ".in" input files}


\begin{verbatim}
# material
msat       	800e3 
aexch      	1.3e-11
alpha      	0.02

# geometry 
gridsize	1     	32      128    
partsize	500e-9	125e-9 	3e-9

# initial magnetization
uniform		1 1 0

# run
autosave	table	ascii	10E-12
run          	1E-9
\end{verbatim}

\newcommand{\defcommand}[2][\space]{\textbf{#2}\index{#2}\label{#2} \textit{#1}}
\newcommand{\command}[1]{\hyperref[#1]{\textbf{#1}}\index{#1}\label{#1}}

\paragraph{Comments} All text after a hashmark (\#) is considered a \idx{comment} and is ignored by the simulation. In the above example, the statements \cmd{\# material}, \cmd{\# geometry}, \ldots are thus comments. They are only included for clarity and could be omitted.

\paragraph{Commands} All the other text in the input file is treated as a series of \idx{commands} that are executed in the order they are specified. In general, the order of the commands matters but should be easy to deduce.  E.g., you can not call \command{run} to start the time evolution when you have not first specified the material parameters, simulation size, etc\ldots. On the other hand, after having {run} the simulation for some time, you \emph{can} change the material parameters and call commands like \command{run} again. Either way, the program will tell you if it can not run a certain command yet because some parameters should be set first. A list of commands is found below.

\subsubsection*{Material parameters}
\begin{tabular}{ll}
\defcommand[value]{msat}  & Sets the saturation magnetization to the value specified in A/m. \\
\defcommand[value]{aexch} & Sets the exchange constant to the value specified in J/m. \\
\defcommand[value]{alpha} & Sets the damping coefficient.
\end{tabular}

\subsubsection*{Part size}
To define the magnet size, you must specify \emph{exactly two} of the three commands below.\\

\begin{tabular}{ll}
\defcommand[x y z]{partsize}  & Sets the size of the magnet, specified in m. \\
\defcommand[x y z]{cellsize}  & Sets the size of the finite difference cells, in m. \\
\defcommand[$N_x$ $N_y$ $N_z$]{gridsize} & Sets the number of finite difference cells.
\end{tabular}\\
\bigskip

\begin{itemize}
 \item After having set two of these values, the remaining one is calculated automatically. E.g. the part size and cell size automatically fix the number of cells.
 \item For performance reasons, the number of cells in each direction should preferentially be a power of two.
 \item For a 2D simulation, one can simply use $N_x \times N_y \times 1$ cells. In that case, optimized algorithms for a 2D geometry are used. Note that only the last dimension ($Z$) can be $1$ cell large, e.g., $1 \times N_y \times N_z$ is not a valid grid size.
\end{itemize}


\subsubsection*{Initial magnetization state}
\begin{tabular}{ll}
\defcommand[$m_x$ $m_y$ $m_z$]{uniform}  & Initializes the magnetization to a uniform state.\\
\defcommand[amplitude]{addnoise} & Adds random noise with the specified amplitude to a previously\\& defined magnetization state.
\end{tabular}




\subsubsection{Applied magnetic field}
\begin{tabular}{ll}
\defcommand[$B_x$ $B_y$ $B_z$]{staticfield}  & Applies a static magnetic field, specified in tesla.\\
\end{tabular}

\subsubsection*{Scheduled output}
\begin{tabular}{ll}
\defcommand[what format interval]{autosave}  & $what$ = m (magnetization) or table.\\
& $format$ = ascii, binary or png.\\
& $interval$ = save output every $interval$ seconds.
\end{tabular}


\subsection{Output}


Upon running an input file, an \idx{output directory} with a corresponding name but ending with ``\file{.out}'' will be created to store the simulation output. It also contains a file \idxfile{output.log} that keeps a log of all the output that appeared on the screen.  


\subsection{\mumax Arguments}

\mumax is generally started by typing:

\shell{\prog \textit{arguments} \textit{inputfile}}

in a terminal. \cmd{\textit{arguments}} represents the (optional) \idx{command line arguments}, starting with a dash (``-'') or double-dash. These should always be specified \emph{before} the input file(s). They are meant for fine-tuning the program's behavior and may often be omitted. Here are the most important cases:

\begin{tabular}{ll}
\idxcmd{-help} & Print a complete list of command-line arguments.\\
\idxcmd{-cpu} & Run on the CPU instead of the GPU. \\
\idxcmd{-gpu=N}&  Run on GPU number ``N'' when multiple GPUs are present.\\& Default value is ``0'', the first GPU. \\
\idxcmd{-silent}&  Do not print output to the screen (only to output.log) \\
\idxcmd{-updatedisp=N}&  Update the ``live'' progress output every N milliseconds \\
\idxcmd{-daemon}&  Run in deamon mode, see \ref{daemon} \\
\idxcmd{-watch=N}&  When running in deamon mode, check for new input files every ``N'' seconds. See \ref{daemon}. \\
\end{tabular}

